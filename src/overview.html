<html>
<head>
<title>CSS4J Overview</title>
</head>
<body>
<p>This project implements an API very similar to W3C's <a href="https://www.w3.org/TR/cssom-1/" target="_blank">CSS Object Model API</a>
in the Java&trade; language, and also adds CSS support to the <a href="https://github.com/dom4j" target="_blank">DOM4J</a> package. It
targets several different use cases, with functionalities from style sheet error detection to style computation.</p>
<div style="margin: 2em 0 2.7em 0" id="overview">
<h2>Overview</h2>
<p>This implementation can be used in several ways: with stand-alone style sheets, with its own <a href="http://www.w3.org/DOM/" target="_blank">DOM</a>
implementation, combined with DOM4J, or by wrapping a pre-existing DOM tree.</p>
<p>You can play with independent style sheets created with the <code>createStyleSheet("<i>title</i>", "<i>media</i>")</code> method of the
<a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html"><code>CSSStyleSheetFactory</code></a> interface.
There are three implementations of that interface:</p>
<ul>
<li><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/dom/CSSDOMImplementation.html"><code>CSSDOMImplementation</code></a>, the native DOM implementation.</li>
<li><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/om/DOMCSSStyleSheetFactory.html"><code>DOMCSSStyleSheetFactory</code></a> for the DOM Wrapper.</li>
<li>If you use DOM4J, get it through <code>XHTMLDocumentFactory.getStyleSheetFactory()</code>.</li>
</ul>
<p>The document back-end is only important if you plan to use the sheets inside a document.
The resulting style sheets are empty, but you can load a style sheet with the <code>AbstractCSSStyleSheet.parseStyleSheet(<i>source</i>)</code>
method (see <a href="#sheetparsing">Parsing a Style Sheet</a>).</p>
<p>One of the most important functionalities in the library is the ability to compute styles for a given element.
In practice, to obtain the 'computed' or 'used' values required for actual rendering a box model implementation is needed, and also
device information. The library provides a simple box model that could be used, but the details of the rendering device can be more difficult.</p>
<p>Depending on the use case, the target device may not be the same one where the library is running (and some exact details hence not available).
To help in the computation, the library defines the <code>DeviceFactory</code> interface to supply device and media-specific data (also provides
the objects required by media queries to work).</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="nativedom">
<h3>Using css4j's native DOM implementation</h3>
<p>You can create a DOM document from scratch and use the related DOM methods to programmatically build a document: just use the provided DOM implementation
(<code>io.sf.carte.doc.dom.CSSDOMImplementation</code>). If you want to parse an existing document, the procedure depends on the type of document: to parse
an XML document (including XHTML documents), you can use this library's <code>XMLDocumentBuilder</code>, while to parse an HTML one (or an
XHTML document that does not use namespace prefixes) you can use the <a href="https://about.validator.nu/htmlparser/" target="_blank">validator.nu
HTML5 parser</a>.</p>
<p>An example with that parser follows:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
import java.io.Reader;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import io.sf.carte.doc.dom.CSSDOMImplementation;
import io.sf.carte.doc.dom.DOMElement;
import io.sf.carte.doc.dom.HTMLDocument;
import io.sf.carte.doc.style.css.CSSComputedProperties;
import io.sf.carte.doc.style.css.CSSTypedValue;
import io.sf.carte.doc.style.css.RGBAColor;
import io.sf.carte.doc.xml.dtd.DefaultEntityResolver;
import nu.validator.htmlparser.dom.HtmlDocumentBuilder;
[...]

// Instantiate DOM implementation (with default settings: no IE hacks accepted)
// and configure it
CSSDOMImplementation impl = new CSSDOMImplementation();
// Alternatively, impl = new CSSDOMImplementation(flags);
// Now load default HTML user agent sheets
impl.setDefaultHTMLUserAgentSheet();
// Prepare builder
HtmlDocumentBuilder builder = new HtmlDocumentBuilder(impl);
// Read the document to parse, and prepare source object
Reader re = ... [reader for HTML document]
InputSource source = new InputSource(re);
// Parse. If the document is not HTML, you want to use DOMDocument instead
HTMLDocument document = (HTMLDocument) builder.parse(source);
re.close();
// Set document URI
document.setDocumentURI("http://www.example.com/mydocument.html");
</pre>
<p>Then you have a CSS-enabled document. To compute styles, use <code>getComputedStyle</code>:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
DOMElement element = document.getElementById("someId");
CSSComputedProperties style = element.getComputedStyle(null);

// Next line could be 'String display = style.getDisplay();'
String display = style.getPropertyValue("display");

// If you use a factory that has been set to setLenientSystemValues(false), next
// line may throw an exception if the 'color' property was not specified.
// The default value for lenientSystemValues is TRUE.
RGBAColor color = ((CSSTypedValue) style.getPropertyCSSValue("color")).getRGBColorValue();

// Suppose that the linked style sheet located at 'css/sheet.css' declares:
// background-image: url('foo.png');

String image_css = style.getPropertyValue("background-image");
String image_uri = ((CSSTypedValue) style.getPropertyCSSValue("background-image")).getStringValue();

// Then, because we already set the document URI to "http://www.example.com/mydocument.html",
// image_css will be set to "url('http://www.example.com/css/foo.png')",
// and image_uri to "http://www.example.com/css/foo.png"
</pre>
<p>The <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSComputedProperties.html"><code>CSSComputedProperties</code></a>
interface extends from an interface similar to W3C's
<a href="https://www.w3.org/TR/cssom-1/#the-cssstyledeclaration-interface" target="_blank"><code>CSSStyleDeclaration</code></a>,
adding methods like <code>getComputedFontSize()</code> or <code>getComputedLineHeight()</code>.</p>
<p>If you are computing styles for a specific medium, tell the document about it (see "<a href="#mediahandling">Media Handling</a>"):</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
document.setTargetMedium("print");
</pre>
<h4 style="margin:1em 0 2em 0" id="conformance">Conformance with the DOM specification</h4>
<p>This library's native DOM implementation has some minor behavior differences with what is written in the <a href="https://www.w3.org/TR/DOM-Level-3-Core/" target="_blank">DOM
Level 3 Core Specification</a>. For example, on elements and attributes the <code>Node.getLocalName()</code> method returns the tag name instead of
<code>null</code> when the node was created with a DOM Level 1 method such as Document.createElement(). Read the <code>io.sf.carte.doc.dom</code> package
description for additional information.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="domwrapper">
<h3>Usage with the DOM Wrapper</h3>
<p>If you choose to build your document with your favorite DOM implementation instead of the CSS4J one or the DOM4J back-end, you can use the <code>DOMCSSStyleSheetFactory.createCSSDocument(document)</code>
method to wrap a pre-existing DOM Document. Example:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
DOMCSSStyleSheetFactory factory = new DOMCSSStyleSheetFactory();
CSSDocument document = factory.createCSSDocument(otherDOMdocument);
</pre>
<p>Unlike the native DOM or the DOM4J back-end, the DOM resulting from the DOM wrapper is read-only, although you can change the
values of some nodes.</p>
</div>
<div style="margin: 2em 0 2.7em 0">
<h3>Consistency of different DOM implementations</h3>
<p>Beware that the computed styles found by each method (native DOM, DOM4J back-end or DOM wrapper) may not be completely identical, due to differences in the
underlying document DOM implementations. Behaviour may vary due to, for example, a pseudo-class like <code>:target</code> being used (DOM4J has no <code>documentURI</code> support so it never matches).</p>
<p>Such cases would be rare, though (no real-world tests have shown that). If you find a difference in styles computed from different back-ends that you believe to be a bug, please report.</p>
</div>
<div id="cascade" style="margin: 2em 0 2.7em 0">
<h3>Configuring the cascade</h3>
<p>Depending on your use case, you may need to set the <a href="https://www.w3.org/TR/css-cascade-3/#origin">user agent (UA) style sheet</a>.
The library supports two different UA sheets, one for <code>STRICT</code> ('standards') mode and another for <code>QUIRKS</code>.
To set either of those sheets, first obtain an instance of the factory that you are using:
</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
// Instantiate the new factory or get it from an object that you are already using.
AbstractCSSStyleSheetFactory cssFactory = ...
</pre>
<p>If you are using the DOM4J classes, you may want to do:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
AbstractCSSStyleSheetFactory cssFactory = XHTMLDocumentFactory.getInstance().getStyleSheetFactory();
</pre>
<p>If you are processing HTML, css4j's default HTML5 UA sheet (based on W3C/WHATWG recommendations) should be
appropriate for you:
</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
cssFactory.setDefaultHTMLUserAgentSheet();
</pre>
<p>But if you want to set your own UA sheet, first obtain a reference to the sheet:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
BaseCSSStyleSheet sheet = cssFactory.getUserAgentStyleSheet(CSSDocument.ComplianceMode.STRICT);
</pre>
<p>This is assuming the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSDocument.ComplianceMode.html#STRICT"><code>STRICT</code></a>
mode, <i>i.e.</i> that you use documents with a <code>DOCTYPE</code>, otherwise use <code>QUIRKS</code> (or you may want to set both UA sheets).
</p>
<p>If the UA sheet already contains rules (it is empty by default), clean it:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
sheet.getCssRules().clear();
</pre>
<p>And now load the new sheet:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
Reader reader = ... [reads the UA sheet]
sheet.parseStyleSheet(reader, CSSStyleSheet.COMMENTS_IGNORE);
reader.close();
</pre>
<p>As the UA sheet's comments are rarely of interest at the OM level, they were ignored during the parse
process (notice the <code>COMMENTS_IGNORE</code> flag).</p>
<p><em>Note: this implementation does not support <code>important</code> style declarations in the UA sheet.</em></p>
<h4>Setting the user style sheet</h4>
<p>There is also the possibility to set a user style sheet (with 'user' origin) via
<a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#setUserStyleSheet(java.io.Reader)"><code>setUserStyleSheet</code></a>:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
Reader reader = ... [reads the user sheet]
cssFactory.setUserStyleSheet(reader);
reader.close();
</pre>
<p>Both <code>important</code> and normal declarations are supported in the
<a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#ORIGIN_USER">user</a> style sheet.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="mediahandling">
<h3>Media Handling</h3>
<p>By default, computed styles only take into account generic styles that are common to all media. If you want to target a more specific medium,
you have to use the <code>CSSDocument.setTargetMedium("<i>medium</i>")</code> method. For example, if your document has the following style sheets linked:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
&lt;link href="http://www.example.com/css/sheet.css" rel="stylesheet" type="text/css" /&gt;
&lt;link href="http://www.example.com/css/sheet_for_print.css" rel="stylesheet" media="print" type="text/css" /&gt;
</pre>
<p>Computed styles will initially take into account only the "sheet.css" style sheet. However, if you execute the following method:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
document.setTargetMedium("print");
</pre>
<p>Then all subsequently computed styles will account for the merged style sheet from "sheet.css" and "sheet_for_print.css".</p>
<p>This way to tie a document with a medium is not totally standard, as the W3C APIs would probably expect a <code>DeviceFactory</code>-related object implementing the
<a href="https://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/css/ViewCSS.html" target="_blank"><code>ViewCSS</code></a> interface and referencing the document,
but this approach allows to isolate DOM logic inside DOM objects and keep the <code>DeviceFactory</code> for media-specific information only.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="sheetsets">
<h3>Style Sheet Sets</h3>
<p>The library supports alternative style sheets. Use CSSDocument's methods enableStyleSheetsForSet, getStyleSheetSets, getSelectedStyleSheetSet and
setSelectedStyleSheetSet. For example, if you have a document with these linked sheets:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
&lt;link href="http://www.example.com/commonsheet.css" rel="stylesheet" type="text/css" /&gt;
&lt;link href="http://www.example.com/alter1.css" rel="alternate stylesheet" type="text/css" title="Alter 1" /&gt;
&lt;link href="http://www.example.com/alter2.css" rel="alternate stylesheet" type="text/css" title="Alter 2" /&gt;
&lt;link href="http://www.example.com/default.css" rel="stylesheet" type="text/css" title="Default" /&gt;
</pre>
<p>Initially, sheets 'alter1.css' and 'alter2.css' will not be used to compute styles. But then you can write code like the following:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
String defset = document.getSelectedStyleSheetSet();  // Sets 'defset' to "Default"
document.setSelectedStyleSheetSet("Alter 1");  // Selects the set with title "Alter 1"
document.setSelectedStyleSheetSet("Alter 2");  // Selects the set with title "Alter 2"
</pre>
<p>These methods have been removed from the DOM standard unfortunately, but you can still read the specification at the <a href="https://www.w3.org/TR/2013/WD-cssom-20131205/#extensions-to-the-document-interface" target="_blank">CSSOM 5 December 2013 Working Draft</a>.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="errorchecking">
<h3>Style Sheet Error Checking</h3>
<p>You can check for errors and warnings in the document's sheets using the non-standard <code>getErrorHandler</code> method. Example:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
if (document.getStyleSheets().item(0).getErrorHandler().hasSacErrors())
	... error processing / reporting
</pre>
<p>The merged style sheet obtained from the <code>getStyleSheet</code> method has the merged error/warning state from the document's active sheets.</p>
<p>A typical source of errors are the non-compliant IE hacks, like prefixing property names with an asterisk (you may want to use the proper
NSAC flags when creating the factory, see <a href="#legacycompat">Compatibility with legacy browsers</a>),
or charset rules found in the wrong place.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="overridestyles">
<h3>Override Styles</h3>
<p>Override styles, that come after the author style sheet in the cascade algorithm, are supported. For example:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
element.getOverrideStyle(null).setCssText("padding: 6pt;");
</pre>
<p>Override styles are defined at the <a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/css.html#CSS-DocumentCSS" target="_blank">DocumentCSS interface</a>.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="sheetparsing">
<h3>Parsing a Style Sheet</h3>
<p>Although document's style sheet fetching and parsing is automatic with this library,
it is possible to manually parse rules from a source stream with the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheet.html#parseStyleSheet(java.io.Reader,short)"><code>CSSStyleSheet.parseStyleSheet(Reader, short)</code></a> method:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
Reader re = ...
sheet.parseStyleSheet(re, COMMENTS_AUTO);
</pre>
<p>The new css rules found in the source stream are added to the already present ones, i.e. the sheet is not reset by this method (although the error handler is).
When the second argument is <code>COMMENTS_IGNORE</code>, the comments in the source stream are ignored when parsing
(see <a href="#sheetcomments"><em>Accessing Style Sheet Comments</em></a>).</p>
<p>The new CSS rules found in the source stream are added to the already present ones, <em>i.e.</em> the sheet is not reset by this method
(although the error handler is), so if you want to refill a sheet you need to clear the rules before parsing:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
sheet.getCssRules().clear();
</pre>
</div>
<div style="margin: 2em 0 2.7em 0" id="legacycompat">
<h3>Compatibility with legacy Browsers</h3>
<p>Today's style sheets often contain non-conformant styles that target specific versions of old web browsers, like Internet Explorer.
Several web sites contain information about that, including:</p>
<ul>
<li><a href="http://browserhacks.com/" target="_blank">browserhacks.com</a></li>
<li><a href="http://www.webdevout.net/css-hacks" target="_blank">www.webdevout.net/css-hacks</a></li>
</ul>
<p>Although it could be argued whether those hacks should be used or not, the point is that actual style sheets do contain them, so this
library supports them.</p>
<p>By default, a factory is configured to use a flagless NSAC parser which would produce an error on any of those non-standard constructs,
but a set of compatibility flags can be specified in the constructors for the factory implementations. The different flags
are documented in the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/nsac/package-summary.html">NSAC javadocs</a>.</p>
<p>The flags available at the time of this guide's update are the following:</p>
<ul>
<li><code>STARHACK</code>. When set, the parser will handle asterisk-prefixed property names as accepted, normal names.</li>
<li><code>IEVALUES</code> supports values ending with <code>\9</code> or <code>\0</code>, as well as
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter" target="_blank"><i>progid</i> filters</a> and
<a href="https://blogs.msdn.microsoft.com/ie/2008/10/16/ending-expressions/" target="_blank">IE expressions</a>.</li>
<li><code>IEPRIO</code> allows values ending with the <code>'!ie'</code> priority hack.</li>
<li><code>IEPRIOCHAR</code> accepts values with an <code>'!important!'</code> priority hack (note the <code>'!'</code> at the end).</li>
</ul>
<p>The object model manages these compatibility values in parallel to standard ones. For example, after parsing this declaration
with <code>IEVALUES</code> set:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
width: 900px; width: 890px\9;
</pre>
<p>its serialization would be identical (if the flag was set correctly):</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
width: 900px; width: 890px\9;
</pre>
<p>but the declaration's length shall be only <code>1</code>. And computed styles only use the standard values unless there are
no alternatives (no standard value was set). The workings are similar for <code>IEPRIO</code> and <code>IEPRIOCHAR</code>:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
width: 890px !ie;
width: 890px !important!;
</pre>
<p>with the last one being handled as of <code>important</code> priority. Values created by <code>IEPRIOCHAR</code> are never used
in computed styles.</p>
<p>Instead, declarations including asterisk-prefixed property names (created by <code>STARHACK</code>) always increase the declaration's
length. For example, the length of the following declaration would be <code>2</code>:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
width: 890px;
*width: 890px;
</pre>
<p>If you want to use these flags at the NSAC level (instead of the Object Model), you may want to read the 'Parser Flags' section in the
NSAC package description, as well as the documentation for the individual flags in
<a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/nsac/Parser.Flag.html"><code>Parser.Flag</code></a>.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="styleformatting">
<h3>CSS Style Formatting</h3>
<p>The serialization of the <code>cssText</code> attribute in <a href="https://www.w3.org/TR/cssom-1/#dom-cssrule-csstext" target="_blank">rules</a> and
<a href="https://www.w3.org/TR/cssom-1/#dom-cssstyledeclaration-csstext">style declarations</a> can be customized with an implementation
of the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/StyleFormattingContext.html">StyleFormattingContext</a> interface.
You can set your <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/StyleFormattingFactory.html">StyleFormattingFactory</a>
(which produces your customized formatting context) to the sheet factory with the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#setStyleFormattingFactory(io.sf.carte.doc.style.css.StyleFormattingFactory)">CSSStyleSheetFactory.setStyleFormattingFactory</a>
method, or subclass your base factory and override the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/om/BaseCSSStyleSheetFactory.html#createDefaultStyleFormattingFactory()">createDefaultStyleFormattingFactory</a> method.</p>
<p>Look at the <a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/om/DefaultStyleFormattingContext.html">DefaultStyleFormattingContext</a> class for an example of a formatting context implementation.</p>
<p>There is also the possibility to customize the default serialization of string values, with the <a href="api/2.0/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#setFactoryFlag(byte)">CSSStyleSheetFactory.setFactoryFlag(byte)</a>
method. You can set two flags that govern which quotation you prefer, or keep the default behaviour:</p>
<ul><li><b>Default:</b> Try to keep the original quotation (single or double quotes), unless the alternative is more efficient.</li>
<li><b><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheetFactory.html#STRING_DOUBLE_QUOTE">STRING_DOUBLE_QUOTE</a>:</b>
Use double quotes unless single quotes are more efficient (when the string contains more double quotes than single).</li>
<li><b><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheetFactory.html#STRING_SINGLE_QUOTE">STRING_SINGLE_QUOTE</a>:</b>
Use single quotes unless double quotes are more efficient (when the string contains more single quotes than double).</li>
</ul>
</div>
<div style="margin: 2em 0 2.7em 0" id="sheetcomments">
<h3>Accessing Style Sheet Comments</h3>
<p>CSS style sheets often have comments, like:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
/* This is a preceding comment */
p {color: blue; } /* This is a trailing comment */
</pre>
<p><em>(XML-style comments can also be present in a style sheet, but both NSAC and the CSSOM skip them.)</em></p>
<p>There is no standard CSSOM API for accessing comments in style sheets, but the <code>AbstractCSSRule.getPrecedingComments()</code>
and <code>getTrailingComments()</code> methods are provided for that:</p>
<pre style="padding: 0.8em;background-color: #f8f5e1">
List&lt;String&gt; comments = document.getStyleSheets().item(0).getCssRules().item(3).getPrecedingComments();
List&lt;String&gt; tcomments = document.getStyleSheets().item(0).getCssRules().item(3).getTrailingComments();
</pre>
<p>By default, comments are parsed with the <code><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_AUTO">COMMENTS_AUTO</a></code>
mode, which should be appropriate for human-readable sheets like the one shown above. But a lot of sheets are serialized
in a way that there are no newline characters (or only a few). For these cases,
<code><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_PRECEDING">COMMENTS_PRECEDING</a></code> could be used in
<code><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html#parseStyleSheet(java.io.Reader,short)">parseStyleSheet(Reader,short)</a></code>,
and all the comments will be considered as belonging to the next rule. With <code><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_IGNORE">COMMENTS_IGNORE</a></code>,
all comments found while parsing the sheet will be ignored.</p>
<p>The comments preceding a rule will be included in the text returned by the sheet's
<code>AbstractCSSStyleSheet.toString()</code> and <code>toStyleString()</code> methods,
while other comments (located at places that cannot be easily related to a rule) are lost.</p>
<p>Comments in the default HTML style sheet are not available, as the parser is instructed to ignore them when parsing.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="renderinterfaces">
<h3>Rendering-oriented interfaces</h3>
<p>To help with the determination of 'used' values and the actual rendering, this library provides a few helper interfaces. The most important are:</p>
<ul><li><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/agent/DeviceFactory.html"><code>DeviceFactory</code></a>. It is not a "factory of devices",
but instead the object that delivers the relevant abstractions for a requested medium: <code>StyleDatabase</code> and <code>CSSCanvas</code>.</li></ul>
<ul><li><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/style/css/StyleDatabase.html"><code>StyleDatabase</code></a>.
Provides medium-specific information like available fonts and colors.</li></ul>
<ul><li><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/agent/CSSCanvas.html"><code>CSSCanvas</code></a>.
Has knowledge of medium-specific information that depends (or may depend) on a specific viewport, like supported media features. It is linked
to a viewport, if there is any. This interface is used to determine the state of active pseudo-classes.</li></ul>
<ul><li><a href="https://css4j.github.io/api/2.0/io/sf/carte/doc/agent/Viewport.html"><code>Viewport</code></a>. It represents a viewport defined
as per the CSS specifications.</li></ul>
<p>The differences between style databases and canvases can be subtle, and for some media features it could be argued that they belong to
one or the other. The basic idea is that style databases should be relatively easy to implement for a given medium, while canvases are
probably only going to exist if there is an actual rendering engine implemented.</p>
</div>
<div style="margin: 2em 0 2.7em 0" id="jrereq">
<h3>Java&trade; Runtime Environment Requirements</h3>
<p>The classes in the binary packages have been compiled with a Java SE compiler with 1.8 compiler compliance level,
except for the <code>module-info</code> file which targets Java 11.</p>
</div>
</body>
</html>
